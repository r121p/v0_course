---
title: "Lite3 Motion SDK Development Guide"
format:
  html:
    embed-resources: true
---

# Lite3 Motion SDK Development Guide

This guide explains how to modify the Lite3 Motion SDK code, upload it to the robot, compile, and execute.

## Overview

The Lite3 Motion SDK controls the Jueying Lite3 quadruped robot. The main components are:

- **`main.cpp`** - Main control loop and timing logic
- **`motionexample.h`** - Header file with class declarations
- **`motionexample.cpp`** - Implementation of motion functions

## File Locations on Robot

```
/home/ysc/Lite3_MotionSDK/
├── main.cpp                    # Main program
├── include/
│   └── motionexample.h         # Header file
├── src/
│   └── motionexample.cpp       # Implementation
└── build/                      # Build directory (created after cmake)
    └── Lite_motion             # Compiled executable
```

---

## Step 1: Editing the Files

### Option A: Edit Locally and Upload

#### 1.1 Copy Files from Robot to Local Machine

```bash
# Copy files from robot to local workspace
scp 'ysc@192.168.2.1:~/Lite3_MotionSDK/main.cpp' .
scp 'ysc@192.168.2.1:~/Lite3_MotionSDK/include/motionexample.h' .
scp 'ysc@192.168.2.1:~/Lite3_MotionSDK/src/motionexample.cpp' .
```

#### 1.2 Edit the Files

**motionexample.h** - Add new function declarations:
```cpp
// Add after StandUp declaration
/// @brief Extend all 4 legs to raise the robot higher
/// @param cmd Issue control command
/// @param time Current timestamp
/// @param data_state Real-time status data of robot
void ExtendAllLegs(RobotCmd &cmd, double time, RobotData &data_state);

/// @brief Lower all 4 legs to bring robot closer to ground
/// @param cmd Issue control command
/// @param time Current timestamp
/// @param data_state Real-time status data of robot
void LowerAllLegs(RobotCmd &cmd, double time, RobotData &data_state);
```

**motionexample.cpp** - Implement the functions:
```cpp
/// @brief Extend all 4 legs to raise the robot higher
void MotionExample::ExtendAllLegs(RobotCmd &cmd, double time, RobotData &data_state) {
  double extend_time = 1.0;
  double cycle_time = 0.001;
  
  // HipY=-25°, Knee=45° (extends leg, raises robot)
  Vec3 goal_angle_extend;
  goal_angle_extend << 0 * kDegree2Radian, -25 * kDegree2Radian, 45 * kDegree2Radian;
  
  if (time <= init_time + extend_time) {
    SwingToAngle(init_angle_fl, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "FL", cmd, data_state);
    SwingToAngle(init_angle_fr, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "FR", cmd, data_state);
    SwingToAngle(init_angle_hl, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "HL", cmd, data_state);
    SwingToAngle(init_angle_hr, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "HR", cmd, data_state);
  } else {
    // Hold position
    for (int leg_side = 0; leg_side < 4; leg_side++) {
      for (int i = 0; i < 3; i++) {
        cmd.joint_cmd[leg_side * 3 + i].kp = 80;
        cmd.joint_cmd[leg_side * 3 + i].kd = 0.7;
        cmd.joint_cmd[leg_side * 3 + i].torque = 0;
      }
      cmd.joint_cmd[leg_side * 3].position = goal_angle_extend[0];
      cmd.joint_cmd[leg_side * 3 + 1].position = goal_angle_extend[1];
      cmd.joint_cmd[leg_side * 3 + 2].position = goal_angle_extend[2];
      cmd.joint_cmd[leg_side * 3].velocity = 0;
      cmd.joint_cmd[leg_side * 3 + 1].velocity = 0;
      cmd.joint_cmd[leg_side * 3 + 2].velocity = 0;
    }
  }
}
```

**main.cpp** - Update the control flow:
```cpp
// In the while(1) loop, update the timing logic:
if(time_tick < 1000){
  robot_set_up_demo.PreStandUp(robot_joint_cmd,now_time,*robot_data);
}
if(time_tick == 1000){
  robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);
}
if(time_tick >= 1000 && time_tick < 4000){
  robot_set_up_demo.StandUp(robot_joint_cmd,now_time,*robot_data);  // Neutral
}
if(time_tick == 4000){
  robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);
}
if(time_tick >= 4000 && time_tick < 6000){
  robot_set_up_demo.ExtendAllLegs(robot_joint_cmd,now_time,*robot_data);  // Raise
}
if(time_tick == 6000){
  robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);
}
if(time_tick >= 6000 && time_tick < 8000){
  robot_set_up_demo.LowerAllLegs(robot_joint_cmd,now_time,*robot_data);   // Lower
}
if(time_tick == 8000){
  robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);
}
if(time_tick >= 8000 && time_tick < 10000){
  robot_set_up_demo.StandUp(robot_joint_cmd,now_time,*robot_data);  // Return to neutral
}
if(time_tick >= 10000){
  send_cmd->ControlGet(ROBOT);  // Return control, enter damping
  break;
}
if(is_message_updated_){
  send_cmd->SendCmd(robot_joint_cmd);  // Send commands to robot
}
```

---

## Step 2: Upload Code to Robot

### 2.1 Copy Files to Robot

```bash
# Upload header file
scp motionexample.h 'ysc@192.168.2.1:~/Lite3_MotionSDK/include/'

# Upload implementation file
scp motionexample.cpp 'ysc@192.168.2.1:~/Lite3_MotionSDK/src/'

# Upload main file
scp main.cpp 'ysc@192.168.2.1:~/Lite3_MotionSDK/'
```

Or all in one command:
```bash
scp motionexample.h 'ysc@192.168.2.1:~/Lite3_MotionSDK/include/' && \
scp motionexample.cpp 'ysc@192.168.2.1:~/Lite3_MotionSDK/src/' && \
scp main.cpp 'ysc@192.168.2.1:~/Lite3_MotionSDK/'
```

### 2.2 Verify Files Were Copied

SSH into the robot and check:
```bash
ssh ysc@192.168.2.1
ls -la ~/Lite3_MotionSDK/
ls -la ~/Lite3_MotionSDK/include/
ls -la ~/Lite3_MotionSDK/src/
```

---

## Step 3: Compile the Code

### 3.1 Navigate to Build Directory

```bash
ssh ysc@192.168.2.1
cd ~/Lite3_MotionSDK/build
```

### 3.2 Build

```bash
# Compile
make -j
```

Expected output:
```
Scanning dependencies of target Lite_motion
[ 33%] Building CXX object CMakeFiles/Lite_motion.dir/main.cpp.o
[ 66%] Building CXX object CMakeFiles/Lite_motion.dir/src/motionexample.cpp.o
[100%] Linking CXX executable Lite_motion
[100%] Built target Lite_motion
```

### 3.3 If Build Directory Doesn't Exist

```bash
cd ~/Lite3_MotionSDK
mkdir -p build
cd build
cmake .. -DBUILD_PLATFORM=arm
make -j
```

---

## Step 4: Execute the Program

### 4.1 Run the Demo

```bash
cd ~/Lite3_MotionSDK/build
./Lite_motion
```

### 4.2 Expected Behavior

The robot will execute this sequence:

| Time (s) | Action | Description |
|----------|--------|-------------|
| 0-1 | PreStandUp | Draw legs in, prepare to stand |
| 1-4 | StandUp | Stand to neutral position |
| 4-6 | ExtendAllLegs | Extend legs, raise body higher |
| 6-8 | LowerAllLegs | Lower legs, crouch down |
| 8-10 | StandUp | Return to neutral position |
| 10+ | Damping | Return control, enter damping mode |

### 4.3 Stop the Program

Press `Ctrl+C` to stop execution (if needed before completion).

---

## Understanding Joint Angles

### Coordinate System
- **HipX (joint 0)**: Rotation around X-axis (0° = neutral)
- **HipY (joint 1)**: Thigh angle (-70° = tucked, -42° = standing, -25° = extended, -55° = lowered)
- **Knee (joint 2)**: Knee angle (150° = tucked, 78° = standing, 45° = extended, 100° = lowered)

### Joint Mapping
```
Leg indices: FL=0, FR=1, HL=2, HR=3
Joint indices per leg: HipX=0, HipY=1, Knee=2
Array index = leg * 3 + joint

Example:
- FL HipY = 0 * 3 + 1 = index 1
- FR Knee = 1 * 3 + 2 = index 5
- HL HipX = 2 * 3 + 0 = index 6
```

---

## Troubleshooting

### "Cannot bind the socket" Error
This means the UDP port is already in use. Make sure no other instance is running:
```bash
ssh ysc@192.168.2.1
ps aux | grep Lite_motion
kill -9 <PID>
```

### Robot Falls Over
Check that the angle values in ExtendAllLegs and LowerAllLegs are correct. The values may need to be swapped depending on robot orientation.

### Build Errors
If you see compilation errors, check:
1. All quotes are properly formatted in the files
2. Include statements have proper quotes: `#include "filename.h"`
3. Function declarations match implementations

---

## Quick Reference

### One-Line Build and Run
```bash
ssh ysc@192.168.2.1 "cd ~/Lite3_MotionSDK/build && make -j && ./Lite_motion"
```

### Restore Original Files
```bash
ssh ysc@192.168.2.1 "cd ~/Lite3_MotionSDK && git checkout -- ."
```

### Check Robot Motion Program
```bash
ssh ysc@192.168.2.1 "pgrep -a jy_exe"
```

---

## Summary Workflow

```bash
# 1. Copy from robot
scp 'ysc@192.168.2.1:~/Lite3_MotionSDK/main.cpp' .
scp 'ysc@192.168.2.1:~/Lite3_MotionSDK/include/motionexample.h' .
scp 'ysc@192.168.2.1:~/Lite3_MotionSDK/src/motionexample.cpp' .

# 2. Edit files locally (use your editor)

# 3. Upload to robot
scp motionexample.h 'ysc@192.168.2.1:~/Lite3_MotionSDK/include/'
scp motionexample.cpp 'ysc@192.168.2.1:~/Lite3_MotionSDK/src/'
scp main.cpp 'ysc@192.168.2.1:~/Lite3_MotionSDK/'

# 4. Build and run
ssh ysc@192.168.2.1 "cd ~/Lite3_MotionSDK/build && make -j && ./Lite_motion"
```

---

**Robot IP**: 192.168.2.1  
**Username**: ysc  
**Build Platform**: ARM (aarch64)

---

## Appendix: Source Code

### main.cpp
```cpp
/// @file main.cpp
/// @author your name (you@domain.com)
/// @brief 
/// @version 0.1
/// @date 2022-09-13 
/// @copyright Copyright (c) 2022


#include "udpsocket.hpp"
#include "udpserver.hpp"
#include "sender.h"
#include "dr_timer.h"
#include "receiver.h"
#include "motionexample.h"
#include <iostream>
#include <time.h>
#include <string.h>

using namespace std;

  bool is_message_updated_ = false; ///< Flag to check if message has been updated
  /**
   * @brief Callback function to set message update flag
   * 
   * @param code The code indicating the type of message received
   */
  void OnMessageUpdate(uint32_t code){
    if(code == 0x0906){
      is_message_updated_ = true;
    }
  }

int main(int argc, char* argv[]){
  DRTimer set_timer;
  double now_time,start_time;
  RobotCmd robot_joint_cmd;
  memset(&robot_joint_cmd, 0, sizeof(robot_joint_cmd));

  Sender* send_cmd          = new Sender("192.168.1.120",43893);              ///< Create send thread
  Receiver* robot_data_recv = new Receiver();                                 ///< Create a receive resolution
  robot_data_recv->RegisterCallBack(OnMessageUpdate);
  MotionExample robot_set_up_demo;                                            ///< Demos for testing can be deleted by yourself
  RobotData *robot_data = &robot_data_recv->GetState();

  robot_data_recv->StartWork();
  set_timer.TimeInit(1);                                                      ///< Timer initialization, input: cycle; Unit: ms
  send_cmd->RobotStateInit();                                                 ///< Return all joints to zero and gain control

  start_time = set_timer.GetCurrentTime();                                    ///< Obtain time for algorithm usage
  robot_set_up_demo.GetInitData(robot_data->joint_data,0.000);                ///< Obtain all joint states once before each stage (action)
  
  int time_tick = 0;
  while(1){
    if (set_timer.TimerInterrupt() == true){                                  ///< Time interrupt flag
      continue;
    }
    now_time = set_timer.GetIntervalTime(start_time);                         ///< Get the current time
    time_tick++;
    if(time_tick < 1000){
      robot_set_up_demo.PreStandUp(robot_joint_cmd,now_time,*robot_data);     ///< Stand up and prepare for action
    }
    if(time_tick == 1000){
      robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);         ///< Obtain all joint states once before each stage (action)
    }
    if(time_tick >= 1000 && time_tick < 4000){
      robot_set_up_demo.StandUp(robot_joint_cmd,now_time,*robot_data);        ///< Full stand up (neutral position)
    }
    if(time_tick == 4000){
      robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);         ///< Record neutral position
    }
    if(time_tick >= 4000 && time_tick < 6000){
      robot_set_up_demo.ExtendAllLegs(robot_joint_cmd,now_time,*robot_data);   ///< Extend all 4 legs (raise higher)
    }
    if(time_tick == 6000){
      robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);         ///< Record extended position
    }
    if(time_tick >= 6000 && time_tick < 8000){
      robot_set_up_demo.LowerAllLegs(robot_joint_cmd,now_time,*robot_data);    ///< Lower all 4 legs (closer to ground)
    }
    if(time_tick == 8000){
      robot_set_up_demo.GetInitData(robot_data->joint_data,now_time);         ///< Record lowered position
    }
    if(time_tick >= 8000 && time_tick < 10000){
      robot_set_up_demo.StandUp(robot_joint_cmd,now_time,*robot_data);         ///< Return to neutral position
    }
    if(time_tick >= 10000){
      send_cmd->ControlGet(ROBOT);                                            ///< Return the control right, input: ROBOT: Original algorithm control of the robot .  SDK: SDK control PS: over 50ms, no data set sent_ Send (cmd), you will lose control, you need to resend to obtain control
      break;
    }
    if(is_message_updated_){
      send_cmd->SendCmd(robot_joint_cmd);
    }
    //cout << robot_data->imu.acc_x << endl;
  }
  return 0;
} 
```

### motionexample.cpp
```cpp
/// @file motionexample.cpp
/// @author ysc (www.deeprobotics.cn)
/// @brief 
/// @version 0.1
/// @date 2023-03-03 
/// @copyright Copyright (c) 2023

#include "motionexample.h"

Vec3 goal_angle_fl, goal_angle_hl, goal_angle_fr, goal_angle_hr;
Vec3 init_angle_fl, init_angle_fr, init_angle_hl, init_angle_hr;
double init_time;

/// @brief Spend 1 s putting the robot's legs away and preparing to stand
/// @param cmd Issue control command
/// @param time Current timestamp
/// @param data_state Real-time status data of robot
void MotionExample::PreStandUp(RobotCmd &cmd, double time,RobotData &data_state) {
  double standup_time = 1.0;
  double cycle_time = 0.001;
  goal_angle_fl << 0 * kDegree2Radian, -70 * kDegree2Radian,
    150 * kDegree2Radian;
  goal_angle_fr << 0 * kDegree2Radian, -70 * kDegree2Radian,
    150 * kDegree2Radian;
  goal_angle_hl << 0 * kDegree2Radian, -70 * kDegree2Radian,
    150 * kDegree2Radian;
  goal_angle_hr << 0 * kDegree2Radian, -70 * kDegree2Radian,
    150 * kDegree2Radian;

  if (time <= init_time + standup_time) {
    SwingToAngle(init_angle_fl, goal_angle_fl, standup_time, time - init_time,
                 cycle_time, "FL", cmd, data_state);
    SwingToAngle(init_angle_fr, goal_angle_fr, standup_time, time - init_time,
                 cycle_time, "FR", cmd,data_state);
    SwingToAngle(init_angle_hl, goal_angle_hl, standup_time, time - init_time,
                 cycle_time, "HL", cmd,data_state);
    SwingToAngle(init_angle_hr, goal_angle_hr, standup_time, time - init_time,
                 cycle_time, "HR", cmd,data_state);
  }
}

/// @brief Spend 1.5s standing
/// @param cmd Issue control command
/// @param time Current timestamp
/// @param data_state Real-time status data of robot
void MotionExample::StandUp(RobotCmd &cmd, double time,RobotData &data_state) {
  double standup_time = 1.5;
  double cycle_time = 0.001;
    goal_angle_fl << 0 * kDegree2Radian, -42 * kDegree2Radian,
      78 * kDegree2Radian;
  goal_angle_fr << 0 * kDegree2Radian, -42 * kDegree2Radian,
      78 * kDegree2Radian;
  goal_angle_hl << 0 * kDegree2Radian, -42 * kDegree2Radian,
      78 * kDegree2Radian;
  goal_angle_hr << 0 * kDegree2Radian, -42 * kDegree2Radian,
      78 * kDegree2Radian;

  if (time <= init_time + standup_time) {
    SwingToAngle(init_angle_fl, goal_angle_fl, standup_time, time - init_time,
                 cycle_time, "FL", cmd, data_state);
    SwingToAngle(init_angle_fr, goal_angle_fr, standup_time, time - init_time,
                 cycle_time, "FR", cmd,data_state);
    SwingToAngle(init_angle_hl, goal_angle_hl, standup_time, time - init_time,
                 cycle_time, "HL", cmd,data_state);
    SwingToAngle(init_angle_hr, goal_angle_hr, standup_time, time - init_time,
                 cycle_time, "HR", cmd,data_state);
  }else{
    for (int i = 0; i < 12; i++) {
      cmd.joint_cmd[i].torque = 0;
      cmd.joint_cmd[i].kp = 80;
      cmd.joint_cmd[i].kd = 0.7;
    }
    for (int i = 0; i < 4; i++) {
      cmd.joint_cmd[3*i].position = 0;
      cmd.joint_cmd[3*i+1].position = -42 * kDegree2Radian;
      cmd.joint_cmd[3*i+2].position = 78 * kDegree2Radian;
      cmd.joint_cmd[3*i].velocity = 0;
      cmd.joint_cmd[3*i+1].velocity = 0;
      cmd.joint_cmd[3*i+2].velocity = 0;
    }
  }
}

/// @brief Extend all 4 legs to raise the robot higher
/// @param cmd Issue control command
/// @param time Current timestamp
/// @param data_state Real-time status data of robot
void MotionExample::ExtendAllLegs(RobotCmd &cmd, double time, RobotData &data_state) {
  double extend_time = 1.0;  // 1 second to extend
  double cycle_time = 0.001;
  
  // Goal angles for extending all legs (raising robot higher)
  // Standing position: HipY=-42, Knee=78
  // Extended position: HipY=-25 (thigh lower/rotated down), Knee=45 (leg straighter)
  Vec3 goal_angle_extend;
  goal_angle_extend << 0 * kDegree2Radian, -25 * kDegree2Radian, 45 * kDegree2Radian;
  
  if (time <= init_time + extend_time) {
    // Extend all 4 legs
    SwingToAngle(init_angle_fl, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "FL", cmd, data_state);
    SwingToAngle(init_angle_fr, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "FR", cmd, data_state);
    SwingToAngle(init_angle_hl, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "HL", cmd, data_state);
    SwingToAngle(init_angle_hr, goal_angle_extend, extend_time, time - init_time,
                 cycle_time, "HR", cmd, data_state);
  } else {
    // Hold the extended position for all legs
    for (int leg_side = 0; leg_side < 4; leg_side++) {
      for (int i = 0; i < 3; i++) {
        cmd.joint_cmd[leg_side * 3 + i].kp = 80;
        cmd.joint_cmd[leg_side * 3 + i].kd = 0.7;
        cmd.joint_cmd[leg_side * 3 + i].torque = 0;
      }
      cmd.joint_cmd[leg_side * 3].position = goal_angle_extend[0];
      cmd.joint_cmd[leg_side * 3 + 1].position = goal_angle_extend[1];
      cmd.joint_cmd[leg_side * 3 + 2].position = goal_angle_extend[2];
      cmd.joint_cmd[leg_side * 3].velocity = 0;
      cmd.joint_cmd[leg_side * 3 + 1].velocity = 0;
      cmd.joint_cmd[leg_side * 3 + 2].velocity = 0;
    }
  }
}

/// @brief Lower all 4 legs to bring robot closer to ground
/// @param cmd Issue control command
/// @param time Current timestamp
/// @param data_state Real-time status data of robot
void MotionExample::LowerAllLegs(RobotCmd &cmd, double time, RobotData &data_state) {
  double lower_time = 1.0;  // 1 second to lower
  double cycle_time = 0.001;
  
  // Goal angles for lowering all legs (bringing robot closer to ground)
  // Standing position: HipY=-42, Knee=78
  // Lowered position: HipY=-55 (thigh higher/rotated up), Knee=100 (knee more bent)
  Vec3 goal_angle_lower;
  goal_angle_lower << 0 * kDegree2Radian, -55 * kDegree2Radian, 100 * kDegree2Radian;
  
  if (time <= init_time + lower_time) {
    // Lower all 4 legs
    SwingToAngle(init_angle_fl, goal_angle_lower, lower_time, time - init_time,
                 cycle_time, "FL", cmd, data_state);
    SwingToAngle(init_angle_fr, goal_angle_lower, lower_time, time - init_time,
                 cycle_time, "FR", cmd, data_state);
    SwingToAngle(init_angle_hl, goal_angle_lower, lower_time, time - init_time,
                 cycle_time, "HL", cmd, data_state);
    SwingToAngle(init_angle_hr, goal_angle_lower, lower_time, time - init_time,
                 cycle_time, "HR", cmd, data_state);
  } else {
    // Hold the lowered position for all legs
    for (int leg_side = 0; leg_side < 4; leg_side++) {
      for (int i = 0; i < 3; i++) {
        cmd.joint_cmd[leg_side * 3 + i].kp = 80;
        cmd.joint_cmd[leg_side * 3 + i].kd = 0.7;
        cmd.joint_cmd[leg_side * 3 + i].torque = 0;
      }
      cmd.joint_cmd[leg_side * 3].position = goal_angle_lower[0];
      cmd.joint_cmd[leg_side * 3 + 1].position = goal_angle_lower[1];
      cmd.joint_cmd[leg_side * 3 + 2].position = goal_angle_lower[2];
      cmd.joint_cmd[leg_side * 3].velocity = 0;
      cmd.joint_cmd[leg_side * 3 + 1].velocity = 0;
      cmd.joint_cmd[leg_side * 3 + 2].velocity = 0;
    }
  }
}

/// @brief Only the current moment and angle are recorded
/// @param data Current joint data
/// @param time Current timestamp
void MotionExample::GetInitData(LegData data, double time) {
  init_time = time;
  // Only the current moment and angle are recorded
  init_angle_fl[0] = data.fl_leg[0].position;
  init_angle_fl[1] = data.fl_leg[1].position;
  init_angle_fl[2] = data.fl_leg[2].position;

  init_angle_fr[0] = data.fr_leg[0].position;
  init_angle_fr[1] = data.fr_leg[1].position;
  init_angle_fr[2] = data.fr_leg[2].position;

  init_angle_hl[0] = data.hl_leg[0].position;
  init_angle_hl[1] = data.hl_leg[1].position;
  init_angle_hl[2] = data.hl_leg[2].position;

  init_angle_hr[0] = data.hr_leg[0].position;
  init_angle_hr[1] = data.hr_leg[1].position;
  init_angle_hr[2] = data.hr_leg[2].position;
}

/// @brief Specifically achieve swinging one leg of the robot to a specified position within a specified time
/// @param initial_angle 
/// @param final_angle
/// @param total_time
/// @param run_time
/// @param cycle_time Control cycle, default is 1ms
/// @param side Control which leg, FL is the left front leg, FR is the right front leg, HL is the left and right leg, and HR is the right rear leg
/// @param cmd Issue control command
/// @param data Real-time status data of robot
void MotionExample::SwingToAngle(Vec3 initial_angle, Vec3 final_angle,
                                 double total_time, double run_time,
                                 double cycle_time, string side,
                                 RobotCmd &cmd,
                                 RobotData &data) {
  Vec3 goal_angle;
  Vec3 goal_angle_next;
  Vec3 goal_angle_next2;
  Vec3 goal_velocity;
  int leg_side;

  if (side == "FL")
    leg_side = 0;
  else if (side == "FR")
    leg_side = 1;
  else if (side == "HL")
    leg_side = 2;
  else if (side == "HR")
    leg_side = 3;
  else
    cout << "Leg Side Error!!!" << endl;

  final_angle = final_angle;
  for (int j = 0; j < 3; j++) {
    CubicSpline(initial_angle[j], 0, (double)final_angle[j], 0, run_time,
                cycle_time, total_time, goal_angle[j], goal_angle_next[j],
                goal_angle_next2[j]);
  }

  goal_velocity = (goal_angle_next - goal_angle) / cycle_time;

  ///< The following two methods can be used to complete joint control. By default, position control mode is used, and hybrid control mode is supported

  ///< Joint pd control - position control method, namely, issuing kp, kd, goal_ angle，goal_ Vel, feedforward force tor=0, joint end completes joint pd control closed-loop
  if(true){
    cmd.joint_cmd[3 * leg_side].kp = 60;
    cmd.joint_cmd[3 * leg_side + 1].kp = 60;
    cmd.joint_cmd[3 * leg_side + 2].kp = 60;
    cmd.joint_cmd[3 * leg_side].kd = 0.7;
    cmd.joint_cmd[3 * leg_side + 1].kd = 0.7;
    cmd.joint_cmd[3 * leg_side + 2].kd = 0.7;
    cmd.joint_cmd[3 * leg_side].position = goal_angle[0];
    cmd.joint_cmd[3 * leg_side + 1].position = goal_angle[1];
    cmd.joint_cmd[3 * leg_side + 2].position = goal_angle[2];
    cmd.joint_cmd[3 * leg_side].velocity = goal_velocity[0];
    cmd.joint_cmd[3 * leg_side + 1].velocity = goal_velocity[1];
    cmd.joint_cmd[3 * leg_side + 2].velocity = goal_velocity[2];
    for (int i = 0; i < 12; i++) {
      cmd.joint_cmd[i].torque = 0;
    }
  } else{
    ///< Joint pd control - force control method, i.e. kp, kd, goal_ angle，goal_ Set level to 0
    ///< The upper layer obtains real-time joint data and compares it with the target, performs pd control, calculates the expected torque of each joint, and sends it as a feedforward force tor to the joint end, which directly executes the target torque
    cmd.joint_cmd[3 * leg_side].kp = 0;
    cmd.joint_cmd[3 * leg_side + 1].kp = 0;
    cmd.joint_cmd[3 * leg_side + 2].kp = 0;
    cmd.joint_cmd[3 * leg_side].kd = 0;
    cmd.joint_cmd[3 * leg_side + 1].kd = 0;
    cmd.joint_cmd[3 * leg_side + 2].kd = 0;
    cmd.joint_cmd[3 * leg_side].position = 0;
    cmd.joint_cmd[3 * leg_side + 1].position = 0;
    cmd.joint_cmd[3 * leg_side + 2].position = 0;
    cmd.joint_cmd[3 * leg_side].velocity = 0;
    cmd.joint_cmd[3 * leg_side + 1].velocity = 0;
    cmd.joint_cmd[3 * leg_side + 2].velocity = 0;
    cmd.joint_cmd[3* leg_side].torque = 60 * (goal_angle[0] - data.joint_data.joint_data[3* leg_side].position)
                                    + 0.7 * (goal_velocity[0] - data.joint_data.joint_data[3* leg_side].velocity);
    cmd.joint_cmd[3* leg_side+1].torque = 80 * (goal_angle[1] - data.joint_data.joint_data[3* leg_side+1].position)
                                    + 0.7 * (goal_velocity[1] - data.joint_data.joint_data[3* leg_side+1].velocity);
    cmd.joint_cmd[3* leg_side+2].torque = 80 * (goal_angle[2] - data.joint_data.joint_data[3* leg_side+2].position)
                                    + 0.7 * (goal_velocity[2] - data.joint_data.joint_data[3* leg_side+2].velocity);
  }
}

/// @brief Interpolation to find the path point, i.e. the target angle for each control cycle
/// @param init_position 
/// @param init_velocity 
/// @param goal_position 
/// @param goal_velocity 
/// @param run_time 
/// @param cycle_time Control cycle, default is 1ms
/// @param total_time 
/// @param sub_goal_position Target angle for the control cycle
/// @param sub_goal_position_next Target angle for the next control cycle
/// @param sub_goal_position_next2 Target angle for the next and next control cycle
void MotionExample::CubicSpline(double init_position, double init_velocity,
                                double goal_position, double goal_velocity,
                                double run_time, double cycle_time,
                                double total_time, double &sub_goal_position,
                                double &sub_goal_position_next,
                                double &sub_goal_position_next2) {
  double a, b, c, d;
  d = init_position;
  c = init_velocity;
  a = (goal_velocity * total_time - 2 * goal_position + init_velocity * total_time +
       2 * init_position) /
      pow(total_time, 3);
  b = (3 * goal_position - goal_velocity * total_time - 2 * init_velocity * total_time -
       3 * init_position) /
      pow(total_time, 2);

  if (run_time > total_time)
    run_time = total_time;
  sub_goal_position = a * pow(run_time, 3) + b * pow(run_time, 2) + c * run_time + d;

  if (run_time + cycle_time > total_time)
    run_time = total_time - cycle_time;
  sub_goal_position_next = a * pow(run_time + cycle_time, 3) +
                      b * pow(run_time + cycle_time, 2) +
                      c * (run_time + cycle_time) + d;

  if (run_time + cycle_time * 2 > total_time)
    run_time = total_time - cycle_time * 2;
  sub_goal_position_next2 = a * pow(run_time + cycle_time * 2, 3) +
                       b * pow(run_time + cycle_time * 2, 2) +
                       c * (run_time + cycle_time * 2) + d;
}
```

### motionexample.h
```cpp
#include "receiver.h"
#include "robot_types.h"
#include <time.h>
#include <string.h>
#include "Eigen/Dense"
using namespace std;
using namespace Eigen;

typedef Matrix< double, 3, 1> Vec3;

const double kDegree2Radian = 3.1415926 / 180;

class MotionExample{
  private:

  public:
    /// @brief Spend 1 s putting the robot's legs away and preparing to stand
    /// @param cmd Issue control command
    /// @param time Current timestamp
    /// @param data_state Real-time status data of robot
    void PreStandUp(RobotCmd &cmd, double time,RobotData &data_state);
    
    /// @brief Spend 1.5s standing
    /// @param cmd Issue control command
    /// @param time Current timestamp
    /// @param data_state Real-time status data of robot
    void StandUp(RobotCmd &cmd, double time,RobotData &data_state);

    /// @brief Extend all 4 legs to raise the robot higher
    /// @param cmd Issue control command
    /// @param time Current timestamp
    /// @param data_state Real-time status data of robot
    void ExtendAllLegs(RobotCmd &cmd, double time, RobotData &data_state);

    /// @brief Lower all 4 legs to bring robot closer to ground
    /// @param cmd Issue control command
    /// @param time Current timestamp
    /// @param data_state Real-time status data of robot
    void LowerAllLegs(RobotCmd &cmd, double time, RobotData &data_state);

    /// @brief Specifically achieve swinging one leg of the robot to a specified position within a specified time
    /// @param initial_angle 
    /// @param final_angle
    /// @param total_time
    /// @param run_time
    /// @param cycle_time Control cycle, default is 1ms
    /// @param side Control which leg, FL is the left front leg, FR is the right front leg, HL is the left and right leg, and HR is the right rear leg
    /// @param cmd Issue control command
    /// @param data Real-time status data of robot
    void SwingToAngle(Vec3 initial_angle, Vec3 final_angle, double total_time, double run_time, double cycle_time, string side, RobotCmd &cmd,  RobotData &data);

    /// @brief Interpolation to find the path point, i.e. the target angle for each control cycle
    /// @param init_position 
    /// @param init_velocity 
    /// @param goal_position 
    /// @param goal_velocity 
    /// @param run_time 
    /// @param cycle_time 
    /// @param total_time 
    /// @param sub_goal_position Target angle for the control cycle
    /// @param sub_goal_position_next Target angle for the next control cycle
    /// @param sub_goal_position_next2 Target angle for the next and next control cycle
    void CubicSpline(double init_position, double init_velocity, double goal_position, double goal_velocity, double run_time, double cycle_time, double total_time, double &sub_goal_position, double &sub_goal_position_next, double &sub_goal_position_next2);
    
    /// @brief Only the current moment and angle are recorded
    /// @param data Current joint data
    /// @param time Current timestamp
    void GetInitData(LegData data, double time);
};
```

### stand_up.cpp
```cpp
/// Stand Up Script for Jueying Lite3
/// Makes the robot stand up and maintain standing position

#include "sender.h"
#include "receiver.h"
#include "dr_timer.h"
#include "motionexample.h"
#include <iostream>
#include <string.h>

using namespace std;

int main(int argc, char* argv[]){
  DRTimer set_timer;
  double now_time, start_time;
  RobotCmd robot_joint_cmd;
  memset(&robot_joint_cmd, 0, sizeof(robot_joint_cmd));

  // Create sender to robot (IP: 192.168.1.120, Port: 43893)
  Sender* send_cmd = new Sender("192.168.1.120", 43893);
  
  // Create receiver for robot data
  Receiver* robot_data_recv = new Receiver();
  RobotData *robot_data = &robot_data_recv->GetState();
  robot_data_recv->StartWork();

  // Initialize timer with 1ms cycle
  set_timer.TimeInit(1);
  
  // Reset all joints to zero and gain control
  cout << "Initializing robot... Please ensure robot is in ready position." << endl;
  send_cmd->RobotStateInit();
  cout << "Robot initialized. Starting stand-up sequence..." << endl;

  // Create motion example
  MotionExample robot_stand;
  
  // Get start time
  start_time = set_timer.GetCurrentTime();
  robot_stand.GetInitData(robot_data->joint_data, 0.0);
  
  int time_tick = 0;
  bool standing_complete = false;
  
  cout << "Standing up... (Press Ctrl+C to stop and release control)" << endl;
  
  while(1){
    if (set_timer.TimerInterrupt() == true){
      continue;
    }
    
    now_time = set_timer.GetIntervalTime(start_time);
    time_tick++;
    
    // Phase 1: Pre-stand (1 second) - fold legs in
    if(time_tick < 1000){
      robot_stand.PreStandUp(robot_joint_cmd, now_time, *robot_data);
    }
    // Phase 2: Stand up (1.5 seconds)
    else if(time_tick < 2500){
      if(time_tick == 1000){
        robot_stand.GetInitData(robot_data->joint_data, now_time);
        cout << "Extending legs..." << endl;
      }
      robot_stand.StandUp(robot_joint_cmd, now_time, *robot_data);
    }
    // Phase 3: Maintain standing position
    else {
      if(!standing_complete){
        cout << "Standing position achieved. Maintaining stance..." << endl;
        standing_complete = true;
      }
      // Continue calling StandUp which maintains position after completion
      robot_stand.StandUp(robot_joint_cmd, now_time, *robot_data);
    }
    
    // Send commands to robot
    send_cmd->SendCmd(robot_joint_cmd);
  }
  
  return 0;
}
```
